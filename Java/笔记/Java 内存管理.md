# Java 内存管理

> Java 内存管理就是对象的分配和释放问题。在 Java 中，内存的分配是由「程序」完成的，而内存的释放是由 Java 垃圾回收器（GC）完成的，这种方式确实简化了程序员的工作，但也同时加重了 JVM 的工作。这也是 Java 程序运行速度较慢的原因之一。

## Java 内存分配策略
Java 程序运行时的内存分配策略有三种，分别是静态分配、栈式分配和堆式分配，三种方式所使用的内存空间分别是静态存储区（方法区）、栈区和堆区。

* **静态存储区（方法区）**：主要存放静态变量。这块「内存」在程序编译时就已经分配好了，并且在程序整个运行期间都存在。
* **栈区**：当方法被执行时，方法体内的局部变量（包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时。这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
* **堆区**：又称动态内存分配，通常就是指程序运行时直接 new 出来的内存，也就是对象的实例，这部分「内存」在不使用时将会被 Java 垃圾回收器来负责回收。

简单的例子：

``` java
public class Sample {
    int s1 = 0;
    Sample mSample1 = new Sample();

    public void method() {
        int s2 = 1;
        Sample mSample2 = new Sample();
    }
}

Sample mSample3 = new Sample();
```
结论：
* Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。
* mSample3 指向的对象实体存放于堆上，包括这个对象的所有成员变量 s1 和 mSample1，但它的引用变量是存在于栈中的。

所以：
1. 局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储在堆中 —— 因为他们属于方法中的变量，生命周期随方法而结束
2. 成员变量全部存储于堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被 new 出来使用的


### 堆 Heap
- 简单理解：每个Java应用都唯一对应一个JVM实例，每一个JVM实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或者数组都放在这个堆中，并由应用所有的线程共享。
- Java中分配堆内存是自动初始化的，Java中所有对象的存储控件都是在堆中分配的，但这些对象的引用则是在栈中分配，也就是一般在建立一个对象时，堆和栈都会分配内存。
- 特点：可以动态地分配内存大小、比较灵活，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。
- 缺点：由于要在运行时动态分配内存，存取速度较慢。
- 主要存放：
	1. 由new创建的对象和数组
	2. this
- 特点：引用数据类型（需要用new来创建），既在栈中分配一个地址空间，又在堆空间分配对象的类变量。

### 栈 Stack
- 简单理解：堆栈（stack）是操作系统在建立某个进程或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有先进后出的特性。
- 特点：存取速度比堆要快，仅次于直接位于CPU中的寄存器。栈中的数据可以共享（意思是：栈中的数据可以被多个变量共同引用）。
- 缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。
- 存放对象：
	1. 一些基本类型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄（例如：在函数中定义的一些基本类型的变量和对象的引用变量）。
	2. 方法的形参直接在栈空间分配，当方法调用完成后从栈空间回收。
- 特殊：
	1. 方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完成后从栈空间回收。
	2. 局部变量new出来之后，在栈控件和堆空间中分配空间，当局部变量生命周期结束后，它的栈空间立刻被回收，它的堆空间等待GC回收。

## 参考
堆：堆是heap，是所谓的动态内存，其中的内存在不需要时可以回收，以分配给新的内存请求，其内存中的数据是无序的，即先分配的和随后分配的内存并没有什么必然的位置关系，释放时也可以没有先后顺序。一般由使用者自由分配，在C语言中malloc分配的就是堆，需要手动释放。 

堆栈:就是stack。实际上是只有一个出入口的队列，即后进先出(frist in , last out)，先分配的内存必定后释放。一般由，由系统自动分配，存放函数的参数值，局部变量等，自动清除。 还有，堆是全局的，堆栈是每个函数进入的时候分一小块，函数返回的时候就释放了，静态和全局变量，new得到的变量，都放在堆中，局部变量放在堆栈中，所以函数返回，局部变量就全没了。

JAVA中的基本类型，其实需要特殊对待。因为，在JAVA中，通过new创建的对象存储在“堆”中，所以用new 创建一个小的、简单的变量，如基本类型等，往往不是很有效。因此，在JAVA中，对于这些类型，采用了与C、C++相同的方法。也就是说，不用new 来创建，而是创建一个并非是“引用”的“自动”变量。这个变量拥有它的“值”，并置于堆栈中，因此更高效。

实际上类的实例方法在内存中是只有一份,不过肯定不会是第一个对象中,如果是第一个对象的话,那么当第一个对象被销毁的时候,那么后面的对象就永远无法调用了。 类的实例方法存在一个专门的区叫方法区（method area）,事实上类刚装载的时候就被装载好了,不过它们在”睡眠”,只是这些方法必须当有对象产生的时候才会”苏醒”.(比如,一个输出类的成员变量的方法,如果连对象都没有,何来的输出成员变量).所以,方法在装载的时候就有了,但是不可用,因为它没有指象任何一个对象.

而静态的又不一样了,静态的东西存在静态存储(static storage)区,他们和类是一个等级的，就是说只要类被装载,它们就可以直接用.(用类名来调用).他们不依赖与任何对象,所以也不能输出任何对象的成员属性.(除非成员属性也是静态的). 每个对象在new的时候都会在堆区中开辟内存,用来保存对象的属性和方法.(实际上方法保存的只是方法区的引用,如果保存的是方法本身,那么试想一下,有多少个对象就得有多少个方法,那么又和第一点中”实例方法在内存中只有一份拷贝”相矛盾了)。 
