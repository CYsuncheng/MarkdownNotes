# python3 阅读笔记
## 入门
> Python 3支持3种不同的数值类型：整型（int）、浮点型（float）、复数（complex）。没有python 2 的 long类型  

在整数除法中，除法（/）计算结果是浮点数，即使两个整数恰好整除，结果也是浮点数。如果只想得到整数的结果，丢弃可能的分数部分，可以使用地板除（//），整数的地板除（//）永远是整数，即使除不尽。

在Python 2中，有时会看到\<\>符号。和!=一样，\<\>也表示不等于，在Python 3中已去除该符号。

## 列表和元组
### 列表
```python
>>> greeting=list('hi')
>>> greeting
['h', 'i']
>>> greeting[1:]=list('ello')
>>> greeting
['h', 'e', 'l', 'l', 'o']
```
可以使用与原序列不等长的序列将分片替换。
```python
>>> field=list('ae')
>>> field
['a', 'e']
>>> field [1:1]=list('bcd')
>>> field
['a', 'b', 'c', 'd', 'e']
```
可以在不替换任何原有元素的情况下在任意位置插入新元素。
分片赋值比append()方法强大多了，append()方法只能在列表尾部增加元素，而分片赋值可以在任意位置增加元素。
```python
>>> field=list('abcde')
>>> field
['a', 'b', 'c', 'd', 'e']
>>> field[1:4]=[]
>>> field
['a', 'e']
```
删除和插入一样，可以对一个序列中任意位置的元素进行删除。
所以通过分片赋值删除元素也是可行的，并且分片赋值删除的功能和del删除的操作结果是一样的。

#### 方法
1. count()方法用于统计某个元素在列表中出现的次数。
2. extend()方法用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。
3. pop()方法用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。
4. remove()方法用于移除列表中某个值的第一个匹配项。
5. 需要对一个序列进行反向迭代，可以使用reversed函数。这个函数并不返回列表，而是返回一个迭代器（Iterator）对象，可以通过list函数把返回的对象转换为列表。
6. 如果希望元素能按特定方式进行排序（不是sort方法默认的按升序排列元素），就可以自定义比较方法。
sort方法有两个可选参数，即key和reverse。例如：
```python
>>> field=['study','python','is','happy']
>>> field.sort(key=len)                   
#按字符串由短到长排序
>>> field
>>> field.sort(key=len,reverse=True)      
#按字符串由长到短排序，传递两个参数
>>> field
['python', 'study', 'happy', 'is']
['is', 'study', 'happy', 'python']
```

### 元组
```python
>>> t = ('a', 'b', ['A', 'B'])
>>> t[2][0] = 'X'
>>> t[2][1] = 'Y'
>>> t
('a', 'b', ['X', 'Y'])
```
表面上看，元组的元素确实变了，其实变的不是元组的元素，而是list列表的元素。元组一开始指向的list列表并没有改成别的list列表，所以元组的“不变”是指每个元素的指向永远不变，如指向'a'就不能改成指向'b'，指向一个list就不能改成指向其他对象，但指向的list列表本身是可变的。

### 迭代
在Python中，内建的zip函数用来进行并行迭代，可以把两个序列合并在一起，返回一个元组的列表，例如：

```python
#! /usr/bin/python3
#-*- coding:UTF-8 -*-
student=['xiaomeng','xiaozhi','xiaoqiang']
number=[1001,1002,1003]
for name,num in zip(student,number):
    print(name,'的学号是：',num)
```
zip函数可以作用于任意数量的序列，并且可以应付不等长的序列，当短序列“用完”时就会停止。

reversed和sorted函数。这两个函数可作用于任何序列或可迭代对象，但不是原地修改对象，而是返回翻转或排序后的版本。

### 列表与元组的区别
1. 最重要的一点是tuple是不可变类型，大小固定，而 list 是可变类型、数据可以动态变化，这种差异使得两者提供的方法、应用场景、性能上都有很大的区别。
2. tuple 用于存储异构(heterogeneous)数据，当做没有字段名的记录来用，比如用 tuple 来记录一个人的身高、体重、年龄。
3. 列表一般用于存储同构数据(homogenous)，同构数据就是具有相同意义的数据，比如下面的都是字符串类型。

#### 循环中的else子句
**在while条件语句为false时，执行else的语句块，在for条件语句为false或结束后没有被break中断时，执行else的语句块**

当你用 for 循环迭代查找列表的中的某个元素时，如果找到了就立刻退出循环，如果迭代完了列表还没找到需要以另外一种形式（比如异常）的方式通知调用者时，用 for...else... 无疑是最好的选择。
``` Python
for i in mylist:
    if i == target:
        break
    process(i)
else:
    raise ValueError("List argument missing terminal flag.")
```

否则只能这样：

``` Python
found = False
for i in mylist:
    if i == target:
        found = True
        break
    process(i)

if not found:
    raise ValueError("List argument missing terminal flag.")
```

## 函数
### 闭包函数

```python
>>>def addx(x):  
>>>    def adder(y): return x + y  
>>>    return adder  
>>> c =  addx(8)  
>>> type(c)  
<type 'function'>  
>>> c.__name__  
'adder'  
>>> c(10)  
18 
```
 
结合这段简单的代码和定义来说明闭包：
如果在一个内部函数里：adder(y)就是这个内部函数，
对在外部作用域（但不是在全局作用域）的变量进行引用：x就是被引用的变量，x在外部作用域addx里面，但不在全局作用域里，
则这个内部函数adder就是一个闭包。

### 递归函数
举个例子，我们来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：
fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n

所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。
于是，fact(n)用递归的方式写出来就是：

```python
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
```

如果我们计算fact(5)，可以根据函数定义看到计算过程如下：

```bash
===> fact(5)
===> 5 * fact(4)
===> 5 * (4 * fact(3))
===> 5 * (4 * (3 * fact(2)))
===> 5 * (4 * (3 * (2 * fact(1))))
===> 5 * (4 * (3 * (2 * 1)))
===> 5 * (4 * (3 * 2))
===> 5 * (4 * 6)
===> 5 * 24
===> 120
```

递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。

使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。

解决递归调用栈溢出的方法是通过**尾递归**优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：

```python
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
```

### 匿名函数
```python
print('列表中大于3 的元素有：',[item for item in filter(lambda x:x>3,[1,2,3,4,5])])
```

### 偏函数
函数在执行时，要带上所有必要的参数进行调用。但是，有时参数可以在函数被调用之前提前获知。这种情况下，一个函数有一个或多个参数预先就能用上，以便函数能用更少的参数进行调用。

## 类
一个类中可定义多个构造方法，但实例化类时只实例化最后的构造方法，即后面的构造方法会覆盖前面的构造方法，并且需要根据最后一个构造方法的形式进行实例化。建议一个类中只定义一个构造函数。

### 继承
在Python中，继承有以下特点：
1. 在继承中，基类的构造方法（\_\_init\_\_() 方法）不会被自动调用，需要在子类的构造方法中专门调用。
2. 在调用基类的方法时需要加上基类的类名前缀，并带上self参数变量。区别于在类中调用普通函数时不需要带self参数。
3. 在Python中，首先查找对应类型的方法，如果在子类中找不到对应的方法，才到基类中逐个查找。
4. 子类获得父类全部非私有的功能。

### 多态
当子类和父类存在相同的run()方法时，子类的run()方法会覆盖父类的run()方法，在代码运行时总是会调用子类的run()方法，称之为多态。

如果一个实例的数据类型是某个子类，那它的数据类型也可以看作是父类。但是反过来就不行
