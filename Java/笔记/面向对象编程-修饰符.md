# 修饰符
> 修饰顶层类的修饰符包括：abstract、public 和 final，而 static、protected 和 private 不能修饰顶层类。成员方法和成员变量可以有多种修饰符，而局部变量只能用 final 修饰。  

## 访问控制修饰符
成员变量、成员方法和构造方法可以处于 4个访问级别中的一个：公开、受保护、默认或私有。顶层类只可以处于公开或默认访问级别，因此顶层类不能用 private和 protected 来修饰。

## abstract 修饰符
> abstract 修饰符可用来修饰类和成员方法。  

没有抽象静态方法，static 和 abstract 不能在一起使用。

抽象类及抽象方法不能被 final 修饰符修饰。因为抽象类只有允许创建其子类 ，它的抽象方法才能被实现，并且只有它的具体子类才能被实例化，final 的用法正好相反。

抽象方法不能被 private 修饰符修饰。这是因为如果方法是抽象的，表示父类只声明具备某种功能，需要子类实现。所以必须对子类可见，否则无意义。

## final 修饰符
> 它可以修饰非抽象类、非抽象成员方法和变量  

* 用 final 修饰的类不能被继承。
* 用 final 修饰的方法不能被子类的方法覆盖。
* 用 final 修饰的变量表示常量 ，只能被赋一次值。

final 不能用来修饰构造方法，因为“方法覆盖 ”这一概念仅适用于类的成员方法，而不适用于类的构造方法，父类的构造方法和子类构造方法之间不存在覆盖关系，因此用 final 修饰构造方法是无意义的。

private 类型的方法默认是 final 类型的。

### final 变量
> final 修饰符可以修饰静态变量、实例变量和局部变量，分别表示静态常量、实例常量和局部常量。  

* final 类型的变量都必须显式初始化。
* 对于 final 类型的实例变量，可以在定义变量时，或者在构造方法中进行初始化。
* 对于 f i n a l类型的静态变量，可以在定义变量时进行初始化，或者在静态代码块中初始化。
* final 变量只能赋一次值。
* 如果将引用类型的变量用 final 修饰，那么该变量只能始终引用一个对象，但可以改变对象的内容。

## static 修饰符
> static 修饰符可以用来修饰类的成员变量、成员方法和代码块。  

* 用 static 修饰的成员变量表示静态变量，可以直接通过类名来访问。
* 用 static 修饰的成员方法表示静态方法，可以直接通过类名来访问。
* 用 static 修饰的程序代码块表示静态代码块，当 java 虚拟机加载类时，就会执行该代码块。
* 它不依赖于类的特定实例，被类的所有实例共享。

### 静态变量和方法
* 静态变量在内存中只有一个备份，能被类的所有实例共享，可作为实例之间进行交流的共享数据。可节省内存使用。
* 因为静态方法不需通过它所属的类的任何实例就会被调用，因此在静态方法中不能使用 this or super 关键字，也不能直接访问所属类的实例变量和实例方法，但是可以直接访问所属类的静态变量和静态方法。
* 一个静态的方法必须提供实现，也就是说不能被定义为抽象方法。static and abstract 永远不能一起使用。
* 所以也就证明了为什么 main 方法一定是静态的，这样 java 虚拟机加载了所属类之后就可以调用 main 方法了，而不用先创建类的实例。

不管是实例方法，还是静态方法，它们的字节码都位于方法区内。Java 编译器把 Java 方法的源程序代码编译成二进制的编码，称为字节码，Java 虚拟机的解析器能够解析这种字节码。

### 静态代码块
> 类中可以包含静态代码块，它不存在于任何方法体中。Java 虚拟机加载类时，会执行这些静态代码块。如果类中包含多个静态块，那么 Java 虚拟机按它们在类中出现的顺序依次执行它们，每个静态代码块只会被执行一次。  

类的构造方法用于初始化类的实例，而类的静态代码块则可用于初始化类，给类的静态变量赋初始值。同样不能直接访问实例变量和方法。

### 静态导入
只能是静态方法或静态变量。