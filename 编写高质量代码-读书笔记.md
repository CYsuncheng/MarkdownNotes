# 编写高质量代码-读书笔记

1. 构造代码块依托构造函数，并优先执行，如果遇到this关键字（也就是构造函数调用自身其他的构造函数时）则不插入构造代码块，造代码块插入到super方法之后执行

2. serialVersionUID 来保证反序列化时类的一致性

3. 静态内部类不持有外部类的引用，在普通内部类中，我们可以直接访问外部类的属性、方法，即使是private类型也可以访问，这是因为内部类持有一个外部类的引用，可以自由访问。而静态内部类，则只可以访问外部类的静态方法和静态属性，其他则不能访问

4. 静态内部类不依赖外部类，普通内部类与外部类之间是相互依赖的关系，内部类实例不能脱离外部类实例，也就是说它们会同生同死，一起声明，一起被垃圾回收器回收。而静态内部类是可以独立存在的

5. 普通内部类不能声明static的方法和变量，注意这里说的是变量，常量（也就是final static修饰的属性）还是可以的，而静态内部类形似外部类，没有任何限制

6. 工具类都不能实例化

7. clone 浅拷贝，实现Cloneable接口

8. arraylist 初始容量是10,到达临界值后，每次扩容1.5倍

9. 局部变量的基本数据类型和引用，存储于栈中，引用的对象实体存储于堆中。因为它们属于方法中的变量，生命周期随方法而结束。

10. 成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体），因为它们属于类，类对象终究是要被new出来使用的。

11. 我们所说的内存泄露，只针对堆内存，他们存放的就是引用指向的对象实体。

12. GC_CONCURRENT: 当我们应用程序的堆内存快要满的时候，系统会自动触发GC操作来释放内存。GC_FOR_MALLOC: 当我们的应用程序需要分配更多内存，可是现有内存已经不足的时候，系统会进行GC操作来释放内存，GC_HPROF_DUMP_HEAP: 当生成HPROF文件的时候，系统会进行GC操作，关于HPROF文件我们下面会讲到，GC_EXPLICIT: 这种情况就是我们刚才提到过的，主动通知系统去进行GC操作，比如调用System.gc()方法来通知系统。或者在DDMS中，通过工具按钮也是可以显式地告诉系统进行GC操作的。

13. 原始类型数组不能作为asList的输入参数，否则会引起程序逻辑混乱。asList方法输入的是一个泛型变长参数，我们知道基本类型是不能泛型化的，也就是说8个基本类型不能作为泛型参数，要想作为泛型参数就必须使用其所对应的包装类型。

14. byte-Byte，boolean-Boolean，short-Short，char-Character，int-Integer，long-Long，float-Float，double-Double

15. 因为ArrayList数组实现了RandomAccess接口（随机存取接口），这也就标志着ArrayList是一个可以随机存取的列表，直接用下标循环取值更快，LinkedList 没有实现，用foreach更快

16. 频繁的插入和删除操作，用 LinkedList

17. 判断集合是否相等时只须关注元素是否相等即可

18. 子列表只是原列表的一个视图（View），所有的修改动作都反映在了原列表上，可以用sublist操作局部列表`list.subList(20, 30).clear();`

19. 生成子列表后，再操作原列表，子列表的size的方法都会报错

20. subList生成子列表后，保持原列表的只读状态

21. Comparable接口可以作为实现类的默认排序法，Comparator接口则是一个类的扩展排序工具

22. 使用binarySearch的二分法查找比indexOf的遍历算法性能上高很多，特别是在大数据集而且目标值又接近尾部时，但是要先排序才行

23. indexOf依赖equals方法查找，binarySearch则依赖compareTo方法查找。 equals是判断元素是否相等，compareTo是判断元素在排序中的位置是否相同

24. 并集：`list1.addAll(list2);`，差集：`list1.removeAll(list2);`交集：`list1.retainAll(list2);`注意retainAll方法会删除list1中没有出现在list2中的元素，无重复的并集：//删除在list1中出现的元素`list2.removeAll(list1);`//把剩余的list2元素加到list1中 `list1.addAll(list2);`

25. Collections的swap方法，该方法会交换两个位置的元素值，`Collections.shuffle(tagClouds);`，就这一句话，即可打乱一个列表的顺序

26. HashMap比ArrayList多了一个层Entry的底层对象封装，多占用了内存，并且它的扩容策略是2倍长度的递增，同时还会依据阀值判断规则(0.75)进行判断，因此相对于ArrayList来说，它就会先出现内存溢出

27. HashMap null值也是可以作为key值的，它的位置永远是在Entry数组中的第一位。HashMap比ArrayList 的查找要快得多，前提是，hashcode 不冲突

28. Vector是ArrayList的多线程版本，HashTable是HashMap的多线程版本

29. 多个线程做对集合做相同操作可能出现线程安全，而分别做不同操作则是同步修改。这里说的是真正的多线程，不是并发修改的问题，比如一个线程增加，一个线程删除，这不属于多线程的范畴

30. SortedSet接口（TreeSet实现了该接口）只是定义了在给集合加入元素时将其进行排序，并不能保证元素修改后的排序结果，因此TreeSet适用于不变量的集合数据排序，比如String、Integer等类型，但不适用于可变量的排序，特别是不确定何时元素会发生变化的数据集合，可以用List来代替，然后再使用Collections.sort()方法对List排序

31. 集合大家族

32. 推荐使用枚举常量代替接口常量或类常量，但是枚举类型不能继承

33. 给枚举类型添加描述

``` java

enum Season {

Spring("春"), Summer("夏"), Autumn("秋"), Winter("冬");

private String desc;

Season(String _desc){

desc = _desc;

}

//获得枚举描述

public String getDesc(){

return desc;

}

}

```

34. switch语句是先计算season变量的排序值，然后与枚举常量的每个排序值进行对比的

35. 建议在switch default后直接抛出一个AssertionError错误

36. 使用枚举来实现工厂方法

``` java

enum CarFactory {

//定义工厂类能生产汽车的类型

FordCar, BuickCar;

//生产汽车

public Car create() {

switch (this) {

case FordCar:

return new FordCar();

case BuickCar:

return new BuickCar();

default:

throw new AssertionError("无效参数");

}

}

}

```

37. 定义一个抽象制造方法create，然后每个枚举项自行实现

``` java

enum CarFactory {

FordCar {

public Car create() {

return new FordCar();

}

},

BuickCar {

public Car create() {

return new BuickCar();

}

};

//抽象生产方法

public abstract Car create();

}

```

38. @Inherited注解，它表示的意思是我们只要把注解@Desc加到父类Bird上，它的所有子类都会自动从父类继承@Desc注解

39. 好好看看注解，枚举可以和注解一起使用

40. List<String>、List<Integer>、List<T>擦除后的类型为List。 List<String>[]擦除后的类型为List[]。List<? extends E>、List<? super E>擦除后的类型为List<E>。 List<T extends Serializable&Cloneable>擦除后为List<Serializable>

41. 泛型结构只参与“读”操作则限定上界（extends关键字），泛型结构只参与“写”操作则限定下界（使用super关键字）

42. List<T>、List<?>、List<Object>这三者都可以容纳所有的对象，但使用的顺序应该是首选List<T>，次之List<?>，最后选择List<Object>，List<T>表示的是List集合中的元素都为T类型，具体类型在运行期决定；List<?>表示的是任意类型，与List<T>类似，而List<Object>则表示List集合中的所有元素为Object类型，因为Object是所有类的父类，所以List<Object>也可以容纳所有的类类型，从这一字面意义上分析，List<T>更符合习惯：编码者知道它是某一个类型，只是在运行期才确定而已List<T>可以进行读写操作

43. List<T>可以进行诸如add、remove等操作，因为它的类型是固定的T类型，在编码期不需要进行任何的转型操作。List<?>是只读类型的，不能进行增加、修改操作，因为编译器不知道List中容纳的是什么类型的元素，也就无法校验类型是否安全了，而且List<?>读取出的元素都是Object类型的，需要主动转型，所以它经常用于泛型方法的返回值。注意，List<?>虽然无法增加、修改元素，但是却可以删除元素，比如执行remove、clear等方法，那是因为它的删除动作与泛型类型无关。

44. 泛型支持使用“&”符号设定多重边界

45. 因为getMethod方法获得的是所有public访问级别的方法，包括从父类继承的方法，而getDeclaredMethod获得是自身类的所有方法，包括公用（public）方法、私有（private）方法等，而且不受限于访问权限

46. Accessible属性只是用来判断是否需要进行安全检查的，如果不需要则直接执行，这就可以大幅度地提升系统性能（当然了，由于取消了安全检查，也可以运行private方法、访问private私有属性了）。经过测试，在大量的反射情况下，设置Accessible为true可以提升性能20倍以上

47. forName只是把一个类加载到内存中，并不保证由此产生一个实例对象，也不会执行任何方法，之所以会初始化static代码，那是由类加载机制所决定的，而不是forName方法决定的。也就是说，如果没有static属性或static代码块，forName就只是加载类，没有任何的执行行为

48. 动态创建数组`String[] strs = (String[])Array.newInstance(String.class, 8);`因为数组比较特殊，要想动态创建和访问数组，基本的反射是无法实现的，“上帝对你关闭一扇门，同时会为你打开另外一扇窗"，于是Java就专门定义了一个Array数组反射工具类来实现动态探知数组的功能

49. 代理模式

50. 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问，transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口，被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化，第三点确实没错（一个静态变量不管是否被transient修饰，均不能被序列化），反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的

51. HashMap有两个参数影响其性能：初始容量和加载因子。默认初始容量是16，加载因子是0.75。容量是哈希表中桶(Entry数组)的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，通过调用 rehash 方法将容量翻倍

52. capacity <<= 1; 位运算符，直接对2进制进行处理，这个等式相当于*2

``` java

static int indexFor(int h, int length) {

return h & (length-1);

}

```

又是位运算，高帅富啊！这里h是通过K的hashCode最终计算出来的哈希值，并不是hashCode本身，而是在hashCode之上又经过一层运算的hash值，length是目前容量。这块的处理很有玄机，与容量一定为2的幂环环相扣，当容量一定是2^n时，h & (length - 1) == h % length，它俩是等价不等效的，位运算效率非常高，实际开发中，很多的数值运算以及逻辑判断都可以转换成位运算，但是位运算通常是难以理解的，因为其本身就是给电脑运算的，运算的是二进制，而不是给人类运算的，人类运算的是十进制，这也是位运算在普遍的开发者中间不太流行的原因(门槛太高)。这个等式实际上可以推理出来，2^n转换成二进制就是1+n个0，减1之后就是0+n个1，如16 -> 10000，15 -> 01111，那根据&位运算的规则，都为1(真)时，才为1，那0≤运算后的结果≤15，假设h <= 15，那么运算后的结果就是h本身，h >15，运算后的结果就是最后三位二进制做&运算后的值，最终，就是%运算后的余数，我想，这就是容量必须为2的幂的原因。