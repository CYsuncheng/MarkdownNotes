# 泛型与容器-泛型
## 泛型
### 类型擦除
Java有 Java编译器和 Java虚拟机，编译器将 Java源代码转换为. class文件，虚拟机加载并运行. class文件。对于泛型类， Java编译器会将泛型代码转换为普通的非泛型代码，将类型参数 T擦除，替换为 Object，插入必要的强制类型转换。 Java虚拟机实际执行的时候，它是不知道泛型这回事的，只知道普通的类及代码。再强调一下， Java泛型是通过擦除实现的，类定义中的类型参数如 T会被替换为 Object，在程序运行过程中，不知道泛型的实际类型参数。

### 泛型的好处
既然只使用普通类和 Object就可以，而且泛型最后也转换为了普通类，那为什么还要用泛型呢？
泛型主要有两个好处：
1. 更好的安全性。
2. 更好的可读性。

语言和程序设计的一个重要目标是将 bug尽量消灭在摇篮里，能消灭在写代码的时候，就不要等到代码写完程序运行的时候。只使用 Object，代码写错的时候，开发环境和编译器不能帮我们发现问题，看代码：
``` Java
Pair pair = new Pair("老马", 1); 
Integer id = (Integer) pair. getFirst(); 
String name = (String) pair. getSecond();
```

写代码时不小心把类型弄错了，不过，代码编译时是没有任何问题的，但运行时程序抛出了类型转换异常 ClassCastException。如果使用泛型，则不可能犯这个错误。还可以省去烦琐的强制类型转换，再加上明确的类型信息，代码可读性也会更好。

**除了泛型类，方法也可以是泛型的，而且，一个方法是不是泛型的，与它所在的类是不是泛型没有什么关系，接口也可以是泛型的**

### 类型参数的限定
1. <?> 无限制通配符
2. <? extends E> extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类
3. <? super E> super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类

指定边界后，类型擦除时就不会转换为 Object了，而是会转换为它的边界类型。

`< T extends Comparable < T > >` 是一种令人费解的语法形式，这种形式称为递归类型限制，可以这么解读： T表示一种数据类型，必须实现 Comparable接口，且必须可以与相同类型的元素进行比较。

#### 不明白
同样是 extends关键字，同样应用于泛型， < T extends E >和 <？ extends E >到底有什么关系？它们用的地方不一样，我们解释一下： 
1. < T extends E >用于定义类型参数，它声明了一个类型参数 T，可放在泛型类定义中类名后面、泛型方法返回值前面。 
2.  <？ extends E >用于实例化类型参数，它用于实例化泛型变量中的类型参数，只是这个具体类型是未知的，只知道它是 E或 E的某个子类型。

#### 通配符使用建议
因此使用通配符的基本原则：
* 如果参数化类型表示一个 T 的生产者（读取），使用 < ? Extends T>;
* 如果它表示一个 T 的消费者（写入），就使用 < ? Super T>；
* 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。

#### 泛型与数组
**引入泛型后，一个令人惊讶的事实是，不能创建泛型数组。**

类型参数之间有继承关系的容器之间是没有关系的，比如，一个 DynamicArray < Integer >对象不能赋值给一个 DynamicArray < Number >变量。不过，数组是可以的。

``` Java
Integer[] ints = new Integer[ 10]; 
Number[] numbers = ints; 
Object[] objs = ints;
```

后面两种赋值都是允许的。数组为什么可以呢？数组是 Java直接支持的概念，它知道数组元素的实际类型，知道 Object和 Number都是 Integer的父类型，所以这个操作是允许的。