# 数组和链表查找效率解释

基于这么几件事实：

1. 一个数组中的元素在内存中的存放是连续的，一条链表中的元素在内存中的存放不一定是连续的。
2. 链表的实现是在当前元素中划分出一块指针域指向下一个元素所在地址。
3. 数组名这个变量中存放的是你这个数组中第一个元素的地址，链表的头结点中存放链表中第一个元素的地址。(不绝对，取决于你的写法)
4. 计算机读写内存中的数据是建立在地址之上的，即根据给定的地址进行相应操作。
5. 数组下标的实际意义是：相对于数组起始地址的地址偏移量。有如下的等价关系：a[i] = *(a + i)

根据事实四，不管是通过数组还是用过链表去访问某一块内存，计算机都需要知道待访问内存的内存地址是多少，我们先假设在已知地址的情况下CPU访问一块内存的时间都是一样的，记为T(就是不考虑cache等等之类更底层的东西，以免问题复杂化[其实是怕暴露我计组学得不好的事实])，在此基础上，倘若你要通过数组下标访问一个元素a[k]的话，根据事实一以及事实五，可以直接得到你要访问的元素的地址*(a + k)，你知道了你要访问的元素的地址之后，只需要再花T的时间就可以进行读或者写了(计算地址的过程当然也要花时间，不过现在我们重点不在这，所以不考虑这个时间)，倘若你要通过链表去找一个元素的时候，根据事实一，由于链表中的数据存储不一定连续，所以之前我们对数组进行操作的那个方法不再适用，但是根据事实二，我们可以依据链表中的指针域，顺藤摸瓜一直向前寻找直到我们要访问的结点假设要访问的结点是链表的第k个元素，那么我们需要按照如下的方式找到第k个结点：node1 -> node2 -> node 3 -> …… -> nodek，在已知地址的前提下需要进行k次访问，也就是需要花kT的时间才可以对我们要操作的元素进行读或者写。这就是链表访问数据要比数组慢的原因。

举个例子吧，[镜头切换到高中，上课时间]你是你们班上的数学科代表，上课上到一半，你的数学老师M让你去找一个老师R，但是你又不认识你数学老师M所说的那个老师R，假设你不能通过其他渠道知道R是哪一个人，也不能知道R在哪儿，这个时候你决定在教室里看到一个老师就问他是不是R(这个画风，好浮夸)，当你来到第一个教室的时候，第一个教师的老师说:”你要找R啊，我知道，他在k-302教室，你直接去找他吧”【通过数组】，然而事实有时候不会那么美好，你来到了第一件教室，问一下第一个老师，他说他不是R，而且他也不知道R在哪儿，他让你去第二件教室问一问，你来了第二件教室，也很不幸，第二个教室的老师也不是R，并且他也不知道R在哪儿，于是你就一个教室一个教室地往下找，终于再第K个教室找到了R，然后你把你数学老师的原话转告给了R：“中午去吃什么？”。【通过链表】所以就是这种感觉。
