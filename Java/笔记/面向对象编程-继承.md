# 继承
## 重写与重载
重写父类方法，子类方法不能缩小父类方法的访问权限。例如，代码中子类的方法是私有的，父类的方法是公共的，子类缩小了父类方法的访问权限，这是无效的方法覆盖，因为假如没有这个限制，将会与Java语言的多态机制发生冲突。为什么子类方法不允许抛出比父类方法更多的异常呢？也是这个原因。

子类隐藏父类的静态方法和子类覆盖父类的实例方法，这两者的区别在于：运行时，Java虚拟机把静态方法和所属的类绑定，而把实例方法和所属的实例绑定。

父类的抽象方法可以被子类通过两种途径覆盖：一是子类实现父类的抽象方法；二是子类重新声明父类的抽象方法。

**覆盖和重载具有以下不同点：**
* 方法覆盖要求参数签名必须一致，而方法重载要求参数签名必须不一致。
* 方法覆盖要求返回类型必须一致，而方法重载对此不作限制。
* 方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类的所有方法（包括从父类中继承而来的方法 ）。
* 方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。
* 父类的一个方法只能被子类覆盖一次，而一个方法在所在的类中可以被重载多次。

## 子类与父类的成员绑定
* 实例方法与引用变量实际引用的对象的方法绑定，这种绑定属于动态绑定，因为是在运行时由Java虚拟机动态决定的。
* 静态方法与引用变量所声明的类型的方法绑定，这种绑定属于静态绑定，因为实际上在编译阶段就已经做了绑定。
* 成员变量（包括静态变量和实例变量）与引用变量所声明的类型的成员变量绑定，这种绑定属于静态绑定，因为实际上在编译阶段就已经做了绑定。

如果是父类引用指向子类对象这种形式，有以下几种情况：
1. 如果子类重写了父类的某个方法，那么此时调用的是子类重写的方法。
2. 如果子类没有重写父类的某个方法，那么此时调用的是父类中的方法。
3. 如果子类新增了父类中不存在的方法，那么这个父类引用是不能调用这个仅在子类中存在的方法中，因为子类对象自动向上转型为了父类对象。
4. 如果子类与父类有同名的成员变量和静态变量，那么由于子类自动向上转型为父类对象，此时调用father.a，那么输出的必然是父类的成员变量和静态变量，这里不存在子类覆盖父类同名变量这一说，因为这里本身可以看做是一个父类对象。
5. 如果是Son son=new Son(),那么这就是实实在在的一个子类对象，那么son.a和son.b，这样就会覆盖父类的同名变量，输出的是子类的成员变量a和静态成员变量b，如果子类中没有同名变量，那么son.a和son.b调用的是父类的a和b。换句话说，也就是子类可以继承父类的成员变量和静态变量，同时可以覆盖父类的成员变量和静态变量。

## 多态
Java语言允许某个类型的引用变量引用子类的实例 ，而且可以对这个引用变量进行类型转换，如果把引用变量转换为子类类型，称为向下转型，如果把引用变量转换为父类类型，称为向上转型。

对于一个引用类型的变量，Java编译器按照它声明的类型来处理。意思就是说，Base b = new sub，引用类型是父类，实例类型是子类，b.subvar（子类的实例变量）这样是不行的，因为Base没有这个变量，要使用需要(Sub)b.subvar 这样的强制类型转换。

Java编译器允许具有直接或间接继承关系的类之间进行类型转换，对于向上转型，不必使用强制类型转换，因为子类的对象肯定也可看作父类的对象。相反则需要强制类型转换。

## 继承的注意事项
* 父类的构造方法不允许调用可被子类覆盖的方法。
* 设计专门被继承的类，否则，可以把类声明为final类型，或者，把这个类的所有构造方法声明为private类型。
* 优先考虑组合，替代继承。