# 注解

## 内置注解
### @Override
修饰一个方法，表示该方法不是当前类首先声明的，而是在某个父类或实现的接口中声明的，当前类“重写”了该方法。

这个注解不写也不会改变这些方法是“重写”的本质，那有什么用呢？它可以减少一些编程错误。如果方法有 Override注解，但没有任何父类或实现的接口声明该方法，则编译器会报错。

### @Deprecated
可以修饰的范围很广，包括类、方法、字段、参数等，它表示对应的代码已经过时了，程序员不应该使用它，不过，它是一种警告，而不是强制性的。

从 Java 9开始，@ Deprecated多了两个属性： since和 forRemoval。 since是一个字符串，表示是从哪个版本开始过时的； forRemoval是一个 boolean值，表示将来是否会删除。

### @SuppressWarnings
表示压制 Java的编译警告，它有一个必填参数，表示压制哪种类型的警告，它也可以修饰大部分代码元素，在更大范围的修饰也会对内部元素起效，比如，在类上的注解会影响到方法，在方法上的注解会影响到代码行。

## 创建注解
@Retention表示注解信息保留到什么时候，取值只能有一个，类型为 RetentionPolicy，它是一个枚举，有三个取值。

* SOURCE：只在源代码中保留，编译器将代码编译为字节码文件后就会丢掉。
* CLASS：保留到字节码文件中，但 Java虚拟机将 class文件加载到内存时不一定会在内存中保留。
* RUNTIME：一直保留到运行时。

如果没有声明@ Retention，则默认为 CLASS。如果没有声明@ Target，默认为适用于所有类型。

与接口和类不同，注解不能继承。不过注解有一个与继承有关的元注解@ Inherited，Test是一个注解，类 Base有该注解， Child继承了 Base但没有声明该注解。 main方法检查 Child类是否有 Test注解，输出为 true，这是因为 Test有注解@ Inherited，如果去掉，输出会变成 false。

注解提升了 Java语言的表达能力，有效地实现了应用功能和底层功能的分离，框架/库的程序员可以专注于底层实现，借助反射实现通用功能，提供注解给应用程序员使用，应用程序员可以专注于应用功能，通过简单的声明式注解与框架/库进行协作。